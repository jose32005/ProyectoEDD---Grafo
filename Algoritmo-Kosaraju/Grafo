public class Grafo<T> {

    private Lista<T> listaNodos; // Lista principal de nodos
    private int numVertices;

    //Constructor
    public Grafo() {
        this.numVertices = 0;
        this.listaNodos = new Lista<>();
    }

    //Metodos
    // Método para agregar un nodo al grafo
    public void agregarNodo(T info) {
        Nodo<T> nodoExistente = listaNodos.obtenerNodo((String) info);
        if (nodoExistente != null) {
            System.out.println("Ya existe un nodo bajo el usuario: " + info + ". No se puede agregar otro.");
        } else {
            listaNodos.insertar(info);
            numVertices++;
        }
    }

    // Método para eliminar un nodo al grafo
    public void eliminarNodo(T info) {
        Nodo<T> nodoAEliminar = listaNodos.obtenerNodo(info);

        if (nodoAEliminar == null) {
            System.out.println("El nodo a eliminar no existe en el grafo");
            return;
        }

        // Desconectar el nodo a eliminar de todos los otros nodos
        Nodo<T> actual = listaNodos.getpPrim();
        while (actual != null) {
            desconectarNodos(actual.gettInfo(), info);
            actual = actual.getpSig();
        }

        // Eliminar el nodo de la lista principal de nodos
        listaNodos.eliminar(info);
        numVertices--;
    }

    // Método para conectar dos nodos en el grafo (agregar arista entre dos nodos)
    public void conectarNodos(T infoOrigen, T infoDestino) {

        if (infoOrigen.equals(infoDestino)) {
            System.out.println("El usuario " + infoOrigen + " no se puede conectar a sí mismo");
            return;
        }
        Nodo<T> nodoOrigen = listaNodos.obtenerNodo(infoOrigen);
        Nodo<T> nodoDestino = listaNodos.obtenerNodo(infoDestino);

        if (nodoOrigen == null || nodoDestino == null) {
            System.out.println("Uno o ambos nodos no existen en el grafo");
            return;
        }

        Nodo<T> adyacente = nodoOrigen.getAdyacentes().obtenerNodo(infoDestino);
        if (adyacente != null) {
            System.out.println("Los nodos " + infoOrigen + " y " + infoDestino + " ya están conectados");
            return;
        }

        nodoOrigen.getAdyacentes().insertar(infoDestino);
    }

    // Método para desconectar dos nodos en el grafo (eliminar arista entre dos nodos)
    public void desconectarNodos(T infoOrigen, T infoDestino) {
        Nodo<T> nodoOrigen = listaNodos.obtenerNodo(infoOrigen);
        Nodo<T> nodoDestino = listaNodos.obtenerNodo(infoDestino);

        if (nodoOrigen == null || nodoDestino == null) {
            System.out.println("Uno o ambos nodos no existen en el grafo");
            return;
        }

        Nodo<T> adyacente = nodoOrigen.getAdyacentes().obtenerNodo(infoDestino);
        if (adyacente == null) {
            System.out.println("Los nodos " + infoOrigen + " y " + infoDestino + " no están conectados");
            return;
        }

        nodoOrigen.getAdyacentes().eliminar(infoDestino);
    }

    // Metodos adaptados
    //Metodo que imprime el grafo
    public void imprimirGrafo() {
        System.out.println("El grafo contiene " + numVertices + " vértices: \n");

        Nodo<T> actual = listaNodos.getpPrim();
        while (actual != null) {
            System.out.print("Vértice " + actual.gettInfo() + ": ");
            escribir(actual.getAdyacentes());
            actual = actual.getpSig();
        }
    }

    //Metodo auxiliar
    public void escribir(Lista<T> lista) {
        Nodo<T> pAux = lista.getpPrim();
        while (pAux != null) {
            System.out.print(pAux.gettInfo() + ", ");
            pAux = pAux.getpSig();
        }
        System.out.println("FIN");
    }

    public Nodo<T> obtenerNodo(T info) {
        return (Nodo<T>) listaNodos.obtenerNodo(info);
    }

    // Algoritmo de Kosaraju
    
    //Paso 1: Crear el orden topologico
    public Pila<Nodo<T>> obtenerOrden() {
        Set<Nodo<T>> visitados = new Set<>();
        Pila<Nodo<T>> pila = new Pila<>();
        Nodo<T> nodoActual = (Nodo<T>) listaNodos.primero();

        while (nodoActual != null) {
            // Caso en que el nodo no se encuentre en el conjunto
            if (!visitados.contiene(nodoActual)) {
                llenarOrden(nodoActual, visitados, pila);
            }
            nodoActual = nodoActual.getpSig();
        }

        return pila;
    }
    
    // Paso 2: Llenar la pila
    public void llenarOrden(Nodo<T> nodo, Set<Nodo<T>> visitados, Pila<Nodo<T>> pila) {
        visitados.agregar((Nodo<T>) nodo); // Marcar el nodo actual como visitado

        // Recorrer los nodos adyacentes
        Nodo<T> adyacenteActual = nodo.getAdyacentes().primero();
        while (adyacenteActual != null) {
            if (!visitados.contiene((Nodo<T>) adyacenteActual)) {
                llenarOrden(adyacenteActual, visitados, pila);
            }
            adyacenteActual = adyacenteActual.getpSig();
        }

        // Insertar el nodo actual a la pila
        pila.insertar(nodo.gettInfo());
    }

    // Paso 3: Creacion del grafo transpuesto invirtiendo las aristas
    public Grafo<T> Transpuesto() {
        Grafo<T> transpuesto = new Grafo<>();

        // Primera pasada: Agregar todos los nodos al grafo transpuesto
        Nodo<T> nodoActual = listaNodos.primero();
        while (nodoActual != null) {
            transpuesto.agregarNodo(nodoActual.gettInfo());
            nodoActual = nodoActual.getpSig();
        }

        // Segunda pasada: Conectar los nodos en el grafo transpuesto
        nodoActual = listaNodos.primero();
        while (nodoActual != null) {
            Nodo<T> adyActual = nodoActual.getAdyacentes().primero();
            while (adyActual != null) {
                transpuesto.conectarNodos(adyActual.gettInfo(), nodoActual.gettInfo());
                adyActual = adyActual.getpSig();
            }
            nodoActual = nodoActual.getpSig();
        }

        return transpuesto;
    }

    // Paso 4: imprimir los sccs
    public void imprimirSCCs() {
        //Obtenemos el orden de la pila
        Pila<Nodo<T>> pila = obtenerOrden();
        Grafo<T> grafoTranspuesto = Transpuesto();
        Set<Nodo<T>> visitados = new Set<>();

        while (!pila.pilaVacia()) {
            // Tomamos el ultimo nodo de la pila
            T elementoActual = (T) pila.eliminar();
            Nodo<T> nodo = obtenerNodo(elementoActual);

            if (!visitados.contiene(nodo)) {
                Pila<Nodo<T>> componente = new Pila<>();
                llenarOrden(grafoTranspuesto.obtenerNodo(nodo.gettInfo()), visitados, componente);
                System.out.print("[ ");
                while (!componente.pilaVacia()) {
                    System.out.print(componente.eliminar() + " ");
                }
                System.out.println("]");
            }
        }
    }

}
